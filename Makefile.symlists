# $Id$
#
# Makefile to create lists of all symbols exported by a set of libraries
#
# Author: Till Straumann <strauman@slac.stanford.edu>
#
# NOTES:
#
#   - set the variables below:
#
#       VPATH = <all directories to search for libraries>
#       CORELIBS = list all 'system' libraries you want to scan (the toolchain
#                  knows where to find them).
#       SITELIBS = list all other libs you want to scan. Add their locations
#                  to VPATH.
#
#   - make -f Makefile.symlists will generate a file 'libxxx.scr'
#     for each library listing all the symbols exported by the library.
#
#   - an INCLUDE line for each 'libxxx.scr' must be added to 'symlist.lds'
#
#   - final linkage errors may occur due to the forced linking of 'dead'
#     library parts. I.e. otherwise unused code forced into the link may
#     reference undefined/unresolvable symbols.
#     In such cases, the libxxx.scr files must be hand-tuned to delete/comment
#     'dead' library parts.
#     Sometimes, it is easier to simply 'define' an unresolved symbol to a
#     bogus value. Note that great care must be taken that the respective
#     symbol is _really_ unused / never referenced.
#
#   - unfortunately, configuring the libxxx.scr files has become more
#     cumbersome with later releases of RTEMS:
#     a) everything that used to be in separate libraries (e.g. pppd)
#        is now included in one huge 'librtemsbsp.a', hence it is
#        much more difficult to identify the unused parts.
#     b) there are name clashes / redundant implementations of
#        code (e.g. in srand48 ppp AND libc). If the libc version is wanted,
#        it's not enough to eliminate srand48 from one of the libxxx.scr
#        - one of the copies must be removed from the actual library.
#

CORELIBS = libgcc.a libstdc++.a libc.a libm.a libsupc++.a

# If you patched the RTEMS Makefiles to get the partial libraries
# installed, use them (note that this list may vary for different
# RTEMS releases; create a list of available libraries

CORELIBS += libblock.a libbsp.a libcsupport.a libdosfs.a libimfs.a
CORELIBS += libmisc.a libnetapps.a libnetchip.a libnetworking.a
CORELIBS += libposix.a librdbg.a librpc.a librtcio.a librtems.a
CORELIBS +=	libsapi.a libscore.a libserialio.a libxdr.a librtems++.a 

#Otherwise, you must use (read comment for the special rule below):

#CORELIBS+=librtemsbsp.a librtemscpu.a

SITELIBS = libbspExt.a libtecla_r.a libspencer_regexp.a

VPATH    = $(RTEMS_SITE_INSTALLDIR)/lib:$(RTEMS_SITE_INSTALLDIR)/$(RTEMS_BSP)/lib


EXTENS = tmpl
SCRIPTDIR = config.$(EXTENS)

SCRIPTS = $(patsubst %.a, $(SCRIPTDIR)/%.scr, $(notdir $(LIBRS)))
LISTSCR = symlist.lds.$(EXTENS)

include $(RTEMS_MAKEFILE_PATH)/Makefile.inc
include $(RTEMS_CUSTOM)
include $(RTEMS_ROOT)/make/leaf.cfg

ifneq (XX$(CORELIBS),XX)
VPATH += $(dir $(foreach lib,$(CORELIBS),$(shell $(CC) -print-file-name=$(lib))))
LIBRS += $(CORELIBS)
endif
LIBRS += $(SITELIBS)


all: $(SCRIPTDIR) $(SCRIPTS) $(LISTSCR)

$(LISTSCR): $(SCRIPTS)
	$(RM) $@
	for scr in $(SCRIPTS); do echo INCLUDE $$scr >> $@; done

$(SCRIPTDIR):
	mkdir $@

$(SCRIPTS):$(SCRIPTDIR)/%.scr:%.a
	$(NM) --defined-only -g -l $^ | awk 'BEGIN { flag=0; }/^[^ \t:]*[:]/{ print "/* "$$1" */"; flag = 1;} { if ( NF >= 3 ) { if ( flag != 0 && NF > 3 ) print "/* "$$4" */"; flag = 0; print "EXTERN("$$3")";} }' > $@

# This command is useful if you only have librtemsbsp.a and librtemscpu.a
# (you need debugging info, however [RTEMS built with -g])
#
# The resulting files is sorted by filenames (including directories) and makes
# it easier to eliminate unwanted stuff. Lines are quite long, however because
# the EXTERN statements are appended to the already pretty long filenames.

$(filter %/librtemscpu.scr %/librtemsbsp.scr,$(SCRIPTS)):$(SCRIPTDIR)/%.scr:%.a
	$(NM) --defined-only -g -l $^ | awk 'BEGIN { flag=0; }/^[^ \t:]*[:]/{ fnam=$$1 ""; flag = 1;} { if ( NF >= 3 ) { if ( flag > 0 ) { printf "\n"; if ( NF > 3 ) printf "/* "$$4" */ "; else printf "/* " fnam " */ "; } flag = 0; printf "EXTERN("$$3") ";} } END {printf "\n";}' | sort > $@
