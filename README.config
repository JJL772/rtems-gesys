HOW TO LINK A SYSTEM EXECUTABLE

Till Straumann, <strauman@slac.stanford.edu>, 2003/4/8

COPYRIGHT/LICENSE: EPICS Open License, see LICENSE file
                   which must be distributed with this README

1. INTRODUCTION
===============

Runtime loading is still quite new to RTEMS.
For a traditional application, the linker just puts
all the required parts from various libraries
(from libbsp to libc) into the final executable.

This doesn't work for a system which wants to 
support dynamic loading, because e.g. parts
of the C library (unused at linkage time) might
be needed _later_, when new code is loaded.

Therefore, the 'system' executable must
contain all relevant parts of basic components/libraries.

The decision which parts are to be considered 'relevant'
and hence should be included in the 'system' executable shall
be termed "system configuration".

This "system configuration" (in a 'antique UNIX' or vxWorks
sense) is in addition to normal RTEMS configuration 
(which is coded in 'config.c' and 'rtems_netconfig.c')
and it is achieved by using linker scripts to enforce
linkage of symbols which are not otherwise referenced.

2. HOW TO GENERATE AND TUNE THE LINKER SCRIPTS
==============================================

2.1 GENERATING THE LINKER SCRIPT TEMPLATES
= = = = = = = = = = = = = = = = = = = = = =

A special linker script 'symlist.lds' together with
the scripts in the 'config' directory enforces linking
all the listed symbols by declaring them EXTERN().

The makefile Makefile.symlist can be used to generate
template scripts from a list of libraries defined in
Makefile.symlist.

make -f Makefile.symlist

NOTES: if you set SITELIBS (either on the command line or
       in the makefile itself), you may have to adapt VPATH
       (see Makefile.symlist).

The resulting scripts 'symlist.lds.tmpl' and 'libxxx.scr' in
the 'config.tmpl' subdirectory have to be copied to 'symlist.lds'
and the 'config' directory, respectively and hand-tuned. 

Selective components from the libraries can be excluded by
commenting or deleting the unwanted symbols from the scripts in
the 'config' directory. Entire libraries can be eliminated by
commenting them in 'symlist.lds'.

Recent versions of RTEMS only build two huge libraries
'librtemscpu.a' and 'librtemsbsp.a'. This is unfortunate,
because it makes it more tedious to eliminate unwanted pieces.

A small RTEMS patch (available in this directory; NOTE: RTEMS
must be configured with --enable-maintainer-mode and you must
have a recent version of the RTEMS-required autotools) will cause
the RTEMS build process to install the individual libraries
'librtemsbsp/librtemscpu' are composed of. CORELIBS should
then list those individual libraries
(ls  <rtems_bsp_install_dir>/lib/lib*.a | grep -v 'librtems\(cpu\|bsp\).a' )

Read the APPENDIX if you cannot or do not want to patch
the RTEMS 'Makefile.am's.

2.2. HOW TO "TUNE" THE TEMPLATE SCRIPTS
= = = = = = = = = = = = = = = = = = = =


When you try to build the system application with the fresh
template scripts, you will most likely end up with linkage
errors. These are due to undefined symbols or multiple defined
symbols.

2.2.1 HOW TO DEAL WITH 'undefined symbol' ERRORS
------------------------------------------------

2.2.1.1 Reasons for Undefined Symbol Errors'
- - - - - - - - - - - - - - - - - - - - - - -

Undefined symbol errors can occur mainly for the following reasons:

2.2.1.1.1 Missing System Configuration Tables
Some subsystems (e.g. networking) rely on symbols being defined
by the application (e.g. 'networking' requires the application
to define 'rtems_bsdnet_config' which our system application 
indeed defines in rtems_netconfig.c). Consider what happened if the
system application did not define 'rtems_bsdnet_config' (e.g. because
networking was deemed unnecessary): the linker scripts would still
declare a lot of networking symbols 'EXTERN()' and hence enforce
linking all the networking code - however, 'rtems_bsdnet_config'
will remain unresolved.

2.2.1.1.2 Missing / Unimplemented System Calls
Some pieces have been ported to RTEMS from other systems
(most notably BSD networking). In order to keep changes against
the original code minimal, the RTEMS maintainers often decided to
leave specific code in the libraries although it references unimplemented
system calls (often UNIX or BSD specific things) or is otherwise
unsupported (e.g. RTEMS claims POSIX but not BSD compliance).
Such "dead" library routines must not be used under RTEMS and
hence linkage must not be enforced by declaring them EXTERN().

2.2.1.1.3 BSP Support Stuff
Some libraries (most notably 'libchip') are intended to be used
by BSPs and should be entirely removed from the system application.
In very rare cases, special action is needed. (E.g. loaded module needs
API call of a driver not referenced by system app -> hand tune scripts
adding an EXTERN() statement.)
It is better to remove 'libchip' entirely and only gradually add
things as needed. Otherwise, you will end up with lots of undefined
references.

2.2.1.1.4 Other 'dead' code
There are other reasons for unused code. One example is a reference
of '__do_global_ctors' from libgcc.a. On some systems, the compiler
uses code from libgcc in combination with special 'start' and 'end'
files to properly wrap the 'main' routine. The 'start' and 'end'
files provide '__do_global_ctors' by embedding it in special ELF
sections of the executable. RTEMS, however uses another method
of initializing static C++ constructors.

2.2.1.2 Recursive Elimination of Undefined Symbol References
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

The linker error message gives the file name referencing the
undefined symbol. E.g.

rtems/cpukit/librpc/src/rpc/rpcdname.c:55: undefined reference to `getdomainname'

The first step consists of eliminating/commenting all EXTERN()
statements following the '/* rpcdname.o: */' line in the respective
'config/libxxx.scr' file. The same operation has to be performed for
all offending files.

However, even after removing rpcdname's EXTERN declarations,
the linker still may produce the same error message - what happened?
The answer is that there are other objects referencing code in 'rpcdname'
which in turn asks for the undefined 'getdomainname'. But how
can we find those objects? Inspect the linker 'map' generated
as a side effect of the link (gcc option '-Wl,-Map,map') and search
for 'rpcdname' from the top and you will find the lines 

rtems/powerpc-rtems/svgm/lib/librtemscpu.a(rpcdname.o)
        rtems/powerpc-rtems/svgm/lib/librtemscpu.a(netname.o) (_rpc_get_default_domain)

These tell you that 'rpcdname.o' was linked because 'netname.o'
needs '_rpc_get_default_domain'. Therefore, you will have to remove
all EXTERN() declarations belonging to 'netname.o'.

Repeating these steps, the link will eventually succeed (in the
'getdomainname' example, after also removing 'netnamer.o').

2.2.2 HOW TO DEAL WITH 'multiple defined symbol' ERRORS
-------------------------------------------------------

Multiply defined symbols are more serious issue. In fact, they must be
considered a bug. You get these errors by forcefully triggering
a 'sleeping name clash'.
Some contributed code (which unfortunately has been made part of
librtemscpu/librtemsbsp - the aforementioned patch also takes care
of removing the worst from librtemscpu/bsp: 'libnetapps' [pppd, telnetd,
httpd]') defines very bad symbols such as 'debug, drand48' which are
either part of the C library already or prone to clashing otherwise.
(The affected code was most likely ported from unix to RTEMS - in the
single-process unix environment, these symbols were not a problem).
There is no clean way to deal with name clashes. You must resolve
them by renaming or removing one of the offending definitions.

2.2.3 FINAL NOTES
-----------------

The SSRL system application does not include the following libraries:

   - libblock    [and depending libdosfs] (unused and at some time in the past
                 I didn't like the implementation with possible negative impact
                 on real-time [task dispatching] latencies).
   - libchip     (and related libserialio, libnetchip) for the aforementioned
                 reason.

   - libmisc     parts of the monitor are used by a loadable module which
                 is directly linked against libmisc

   - libnetapps  contains a lot of name clashes and other unused things.
                 We use our own variant of telnetd as a loadable module.
                 All the stuff in this library does not belong into RTEMS core.

It is a good idea to revise the scripts tuned so far and eliminate
EXTERN()s for symbols which do not seem to belong into the system - YMMV.

Tuning the scripts might seem like a very tedious work but once you know
the trick it's actually not that hard. It takes me ~1h now to eliminate
all recursive undefined symbol references.

Also consider that most of the scripts can probably be re-used when
upgrading to a new version of RTEMS although libgcc.scr and the C++
related scripts certainly need to be regenerated when upgrading the
toolchain.

APPENDIX

What if I don't have the individual libraries 'librtemsbsp/cpu' are assembled of?

	A) You might find them in the 'build' tree. Look into 
       '<arch>/c/<bsp>/wrapup/Makefile' and <arch>/c/<bsp>/exec/wrapup/Makefile'
       for where the individual pieces come from.

    B) use the librtemsbsp.scr and librtemscpu.scr linker script templates.
       These have a different format than the other templates which
       is especially useful if you built RTEMS with debugging support.

       The template has all EXTERN statements for a particular object on 
       a single line starting with the object file name.

       All the lines are sorted according to the object file names and
       hence finding files belonging to 'libchip' or 'libmisc' is easy.
       Note that not all 'partial' libraries' (e.g. libnetapps') objects
       are under a subdirectory with such a descriptive name.

       Also note that the task becomes more difficult if librtemscpu/bsp
       have not been compiled with debugging support as in this case
       the object files' path name is missing.

       Makefile.symlists produces a warning message about an ignored/overridden
       rule when generating the librtemsbsp/cpu templates. This message
       can be ignored.
